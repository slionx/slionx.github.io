<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title></title>
      <link href="/2018/10/20/php-cheng-xu-yuan-ru-he-li-jie-ioc/"/>
      <url>/2018/10/20/php-cheng-xu-yuan-ru-he-li-jie-ioc/</url>
      
        <content type="html"><![CDATA[<h1 id="思想"><a href="#思想" class="headerlink" title="思想"></a>思想</h1><blockquote><p>思想是解决问题的根本<br>思想必须转换成习惯<br>构建一套完整的思想体系是开发能力成熟的标志<br>——《简单之美》（前言）</p></blockquote><blockquote><p>“成功的软件项目就是那些提交产物达到或超出客户的预期的项目，而且开发过程符合时间和费用上的要求，结果在面对变化和调整时有弹性。”<br>——《面向对象分析与设计》（第3版）P.236</p></blockquote><h1 id="术语介绍"><a href="#术语介绍" class="headerlink" title="术语介绍"></a>术语介绍</h1><p>——引用《Spring 2.0 技术手册》林信良</p><h2 id="非侵入性-No-intrusive"><a href="#非侵入性-No-intrusive" class="headerlink" title="非侵入性 No intrusive"></a>非侵入性 No intrusive</h2><ul><li><p>框架的目标之一是非侵入性（No intrusive）</p></li><li><p>组件可以直接拿到另一个应用或框架之中使用</p></li><li><p>增加组件的可重用性（Reusability）</p></li></ul><h2 id="容器（Container）"><a href="#容器（Container）" class="headerlink" title="容器（Container）"></a>容器（Container）</h2><ul><li><p>管理对象的生成、资源取得、销毁等生命周期</p></li><li><p>建立对象与对象之间的依赖关系</p></li><li><p>启动容器后，所有对象直接取用，不用编写任何一行代码来产生对象，或是建立对象之间的依赖关系。</p></li></ul><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><ul><li><p>控制反转 Inversion of Control</p></li><li><p>依赖关系的转移</p></li><li><p>依赖抽象而非实践</p></li></ul><h2 id="DI"><a href="#DI" class="headerlink" title="DI"></a>DI</h2><ul><li><p>依赖注入 Dependency Injection</p></li><li><p>不必自己在代码中维护对象的依赖</p></li><li><p>容器自动根据配置，将依赖注入指定对象</p></li></ul><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><ul><li><p>Aspect-oriented programming</p></li><li><p>面向方面编程</p></li><li><p>无需修改任何一行程序代码，将功能加入至原先的应用程序中，也可以在不修改任何程序的情况下移除。</p></li></ul><h2 id="分层"><a href="#分层" class="headerlink" title="分层"></a>分层</h2><blockquote><p>表现层：提供服务，显示信息。<br>领域层：逻辑，系统中真正的核心。<br>数据源层：与数据库、消息系统、事务管理器及其它软件包通信。<br>——《企业应用架构模式》P.14</p></blockquote><h1 id="代码演示IoC"><a href="#代码演示IoC" class="headerlink" title="代码演示IoC"></a>代码演示IoC</h1><p>假设应用程序有储存需求，若直接在高层的应用程序中调用低层模块API，导致应用程序对低层模块产生依赖。</p><pre><code>/** * 高层 */class Business{    private $writer;    public function __construct()    {        $this-&gt;writer = new FloppyWriter();    }    public function save()    {        $this-&gt;writer-&gt;saveToFloppy();    }}/** * 低层，软盘存储 */class FloppyWriter{    public function saveToFloppy()    {        echo __METHOD__;    }}$biz = new Business();$biz-&gt;save(); // FloppyWriter::saveToFloppy</code></pre><p>假设程序要移植到另一个平台，而该平台使用USB磁盘作为存储介质，则这个程序无法直接重用，必须加以修改才行。本例由于低层变化导致高层也跟着变化，不好的设计。</p><p>正如前方提到的</p><blockquote><p>控制反转 Inversion of Control<br>依赖关系的转移<br>依赖抽象而非实践</p></blockquote><p>程序不应该依赖于具体的实现，而是要依赖抽像的接口。请看代码演示</p><pre class=" language-bash"><code class="language-bash">/** * 接口 */interface IDeviceWriter<span class="token punctuation">{</span>    public <span class="token keyword">function</span> saveToDevice<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span>/** * 高层 */class Business<span class="token punctuation">{</span>    /**     * @var IDeviceWriter     */    private <span class="token variable">$writer</span><span class="token punctuation">;</span>    /**     * @param IDeviceWriter <span class="token variable">$writer</span>     */    public <span class="token keyword">function</span> setWriter<span class="token punctuation">(</span><span class="token variable">$writer</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span>-<span class="token operator">></span>writer <span class="token operator">=</span> <span class="token variable">$writer</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    public <span class="token keyword">function</span> save<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span>-<span class="token operator">></span>writer-<span class="token operator">></span>saveToDevice<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>/** * 低层，软盘存储 */class FloppyWriter implements IDeviceWriter<span class="token punctuation">{</span>    public <span class="token keyword">function</span> saveToDevice<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> __METHOD__<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span>/** * 低层，USB盘存储 */class UsbDiskWriter implements IDeviceWriter<span class="token punctuation">{</span>    public <span class="token keyword">function</span> saveToDevice<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token keyword">echo</span> __METHOD__<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$biz</span> <span class="token operator">=</span> new Business<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$biz</span>-<span class="token operator">></span>setWriter<span class="token punctuation">(</span>new UsbDiskWriter<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token variable">$biz</span>-<span class="token operator">></span>save<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> // UsbDiskWriter::saveToDevice<span class="token variable">$biz</span>-<span class="token operator">></span>setWriter<span class="token punctuation">(</span>new FloppyWriter<span class="token punctuation">(</span><span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token variable">$biz</span>-<span class="token operator">></span>save<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> // FloppyWriter::saveToDevice</code></pre><p>控制权从实际的FloppyWriter转移到了抽象的IDeviceWriter接口上，让Business依赖于IDeviceWriter接口，且FloppyWriter、UsbDiskWriter也依赖于IDeviceWriter接口。</p><p>这就是IoC，面对变化，高层不用修改一行代码，不再依赖低层，而是依赖注入，这就引出了DI。</p><p>比较实用的注入方式有三种：</p><ul><li>Setter injection 使用setter方法</li><li>Constructor injection 使用构造函数</li><li><p>Property Injection 直接设置属性</p><p>事实上不管有多少种方法，都是IoC思想的实现而已，上面的代码演示的是Setter方式的注入。</p><h1 id="依赖注入容器-Dependency-Injection-Container"><a href="#依赖注入容器-Dependency-Injection-Container" class="headerlink" title="依赖注入容器 Dependency Injection Container"></a>依赖注入容器 Dependency Injection Container</h1></li><li><p>管理应用程序中的『全局』对象（包括实例化、处理依赖关系）。</p></li><li>可以延时加载对象（仅用到时才创建对象）。</li><li><p>促进编写可重用、可测试和松耦合的代码。</p><p>理解了IoC和DI之后，就引发了另一个问题，引用Phalcon文档描述如下：</p><p>如果这个组件有很多依赖， 我们需要创建多个参数的setter方法​​来传递依赖关系，或者建立一个多个参数的构造函数来传递它们，另外在使用组件前还要每次都创建依赖，这让我们的代码像这样不易维护</p></li></ul><pre class=" language-bash"><code class="language-bash">//创建依赖实例或从注册表中查找<span class="token variable">$connection</span> <span class="token operator">=</span> new Connection<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$session</span> <span class="token operator">=</span> new Session<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$fileSystem</span> <span class="token operator">=</span> new FileSystem<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$filter</span> <span class="token operator">=</span> new Filter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$selector</span> <span class="token operator">=</span> new Selector<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//把实例作为参数传递给构造函数<span class="token variable">$some</span> <span class="token operator">=</span> new SomeComponent<span class="token punctuation">(</span><span class="token variable">$connection</span>, <span class="token variable">$session</span>, <span class="token variable">$fileSystem</span>, <span class="token variable">$filter</span>, <span class="token variable">$selector</span><span class="token punctuation">)</span><span class="token punctuation">;</span>// <span class="token punctuation">..</span>. 或者使用setter<span class="token variable">$some</span>-<span class="token operator">></span>setConnection<span class="token punctuation">(</span><span class="token variable">$connection</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$some</span>-<span class="token operator">></span>setSession<span class="token punctuation">(</span><span class="token variable">$session</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$some</span>-<span class="token operator">></span>setFileSystem<span class="token punctuation">(</span><span class="token variable">$fileSystem</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$some</span>-<span class="token operator">></span>setFilter<span class="token punctuation">(</span><span class="token variable">$filter</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$some</span>-<span class="token operator">></span>setSelector<span class="token punctuation">(</span><span class="token variable">$selector</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>假设我们必须在应用的不同地方使用和创建这些对象。如果当你永远不需要任何依赖实例时，你需要去删掉构造函数的参数，或者去删掉注入的setter。为了解决这样的问题，我们再次回到全局注册表创建组件。不管怎么样，在创建对象之前，它增加了一个新的抽象层：</p><pre class=" language-bash"><code class="language-bash">    class SomeComponent<span class="token punctuation">{</span>    // <span class="token punctuation">..</span>.    /**     * Define a factory method to create SomeComponent instances injecting its dependencies     */    public static <span class="token keyword">function</span> factory<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$connection</span> <span class="token operator">=</span> new Connection<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$session</span> <span class="token operator">=</span> new Session<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$fileSystem</span> <span class="token operator">=</span> new FileSystem<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$filter</span> <span class="token operator">=</span> new Filter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$selector</span> <span class="token operator">=</span> new Selector<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> new self<span class="token punctuation">(</span><span class="token variable">$connection</span>, <span class="token variable">$session</span>, <span class="token variable">$fileSystem</span>, <span class="token variable">$filter</span>, <span class="token variable">$selector</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>瞬间，我们又回到刚刚开始的问题了，我们再次创建依赖实例在组件内部！我们可以继续前进，找出一个每次能奏效的方法去解决这个问题。但似乎一次又一次，我们又回到了不实用的例子中。</p><p>一个实用和优雅的解决方法，是为依赖实例提供一个容器。这个容器担任全局的注册表，就像我们刚才看到的那样。使用依赖实例的容器作为一个桥梁来获取依赖实例，使我们能够降低我们的组件的复杂性：</p><pre class=" language-bash"><code class="language-bash">class SomeComponent<span class="token punctuation">{</span>    protected <span class="token variable">$_di</span><span class="token punctuation">;</span>    public <span class="token keyword">function</span> __construct<span class="token punctuation">(</span><span class="token variable">$di</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        <span class="token variable">$this</span>-<span class="token operator">></span>_di <span class="token operator">=</span> <span class="token variable">$di</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    public <span class="token keyword">function</span> someDbTask<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        // 获得数据库连接实例        // 总是返回一个新的连接        <span class="token variable">$connection</span> <span class="token operator">=</span> <span class="token variable">$this</span>-<span class="token operator">></span>_di-<span class="token operator">></span>get<span class="token punctuation">(</span><span class="token string">'db'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    public <span class="token keyword">function</span> someOtherDbTask<span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">{</span>        // 获得共享连接实例        // 每次请求都返回相同的连接实例        <span class="token variable">$connection</span> <span class="token operator">=</span> <span class="token variable">$this</span>-<span class="token operator">></span>_di-<span class="token operator">></span>getShared<span class="token punctuation">(</span><span class="token string">'db'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        // 这个方法也需要一个输入过滤的依赖服务        <span class="token variable">$filter</span> <span class="token operator">=</span> <span class="token variable">$this</span>-<span class="token operator">></span>_di-<span class="token operator">></span>get<span class="token punctuation">(</span><span class="token string">'filter'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token variable">$di</span> <span class="token operator">=</span> new Phalcon\DI<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//在容器中注册一个db服务<span class="token variable">$di</span>-<span class="token operator">></span>set<span class="token punctuation">(</span><span class="token string">'db'</span>, function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> new Connection<span class="token punctuation">(</span>array<span class="token punctuation">(</span>        <span class="token string">"host"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"localhost"</span>,        <span class="token string">"username"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"root"</span>,        <span class="token string">"password"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"secret"</span>,        <span class="token string">"dbname"</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token string">"invo"</span>    <span class="token punctuation">))</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//在容器中注册一个filter服务<span class="token variable">$di</span>-<span class="token operator">></span>set<span class="token punctuation">(</span><span class="token string">'filter'</span>, function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> new Filter<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//在容器中注册一个session服务<span class="token variable">$di</span>-<span class="token operator">></span>set<span class="token punctuation">(</span><span class="token string">'session'</span>, function<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> new Session<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>//把传递服务的容器作为唯一参数传递给组件<span class="token variable">$some</span> <span class="token operator">=</span> new SomeComponent<span class="token punctuation">(</span><span class="token variable">$di</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$some</span>-<span class="token operator">></span>someTask<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这个组件现在可以很简单的获取到它所需要的服务，服务采用延迟加载的方式，只有在需要使用的时候才初始化，这也节省了服务器资源。这个组件现在是高度解耦。例如，我们可以替换掉创建连接的方式，它们的行为或它们的任何其他方面，也不会影响该组件。</p><h1 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h1><ul><li><p><a href="/a/1190000002424023">PHP程序员如何理解依赖注入容器(dependency injection container)</a></p></li><li><p><a href="http://docs.phalconphp.com/zh/latest/reference/di.html" target="_blank" rel="noopener">http://docs.phalconphp.com/zh/latest/reference/di.html</a></p></li><li><p><a href="http://fabien.potencier.org/article/11/what-is-dependency-injection" target="_blank" rel="noopener">What is Dependency Injection? Fabien Potencier</a></p></li><li><p><a href="http://martinfowler.com/articles/injection.html" target="_blank" rel="noopener">Inversion of Control Containers and the Dependency Injection pattern</a> by Martin Fowler</p></li></ul><h1 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h1><p>很多代码背后，都是某种哲学思想的体现。</p><p>以下引用《面向模式的软件架构》卷1模式系统第六章模式与软件架构</p><h2 id="软件架构支持技术（开发软件时要遵循的基本原则）"><a href="#软件架构支持技术（开发软件时要遵循的基本原则）" class="headerlink" title="软件架构支持技术（开发软件时要遵循的基本原则）"></a>软件架构支持技术（开发软件时要遵循的基本原则）</h2><ol><li><p>抽象</p></li><li><p>封装</p></li><li><p>信息隐藏</p></li><li><p>分离关注点</p></li><li><p>耦合与内聚</p></li><li><p>充分、完整、简单</p></li><li><p>策略与实现分离</p><pre><code>*   策略组件负责上下文相关决策，解读信息的语义和含义，将众多不同结果合并或选择参数值*   实现组件负责执行定义完整的算法，不需要作出与上下文相关的决策。上下文和解释是外部的，通常由传递给组件的参数提供。</code></pre></li><li><p>接口与实现分离</p><pre><code>*   接口部分定义了组件提供的功能以及如何使用该组件。组件的客户端可以访问该接口。*   实现部分包含实现组件提供的功能的实际代码，还可能包含仅供组件内部使用的函数和数据结构。组件的客户端不能访问其实现部分。</code></pre></li><li><p>单个引用点</p><pre><code>*   软件系统中的任何元素都应只声明和定义一次，避免不一致性问题。10. 分而治之</code></pre></li></ol><h2 id="软件架构的非功能特性"><a href="#软件架构的非功能特性" class="headerlink" title="软件架构的非功能特性"></a>软件架构的非功能特性</h2><ol><li><p>可修改性</p><pre><code>*   可维护性*   可扩展性*   重组*   可移植性</code></pre></li><li><p>互操作性</p><pre><code>*   与其它系统或环境交互</code></pre></li><li><p>效率</p></li><li><p>可靠性</p><pre><code>*   容错：发生错误时确保行为正确并自行修复*   健壮性：对应用程序进行保护，抵御错误的使用方式和无效输入，确保发生意外错误时处于指定状态。</code></pre></li><li><p>可测试性</p></li><li><p>可重用性</p><pre><code>*   通过重用开发软件*   开发软件时考虑重用</code></pre></li></ol>]]></content>
      
      
      
    </entry>
    
    <entry>
      <title>hexo command</title>
      <link href="/2018/10/17/hexo-command/"/>
      <url>/2018/10/17/hexo-command/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><h3 id="Create-a-new-Types"><a href="#Create-a-new-Types" class="headerlink" title="Create a new Types"></a>Create a new Types</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"new Types"</span> </code></pre><h3 id="Create-a-new-tags"><a href="#Create-a-new-tags" class="headerlink" title="Create a new tags"></a>Create a new tags</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"new tags"</span> </code></pre><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
  
  
</search>
